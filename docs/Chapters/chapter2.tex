\chapter{Implementacja serwera LSP}
Dysponując parserem kodu Lua, wystarczy odpowiednio przechodzić generowane przez niego drzewa, w celu odpowiedzi na poszczególne zapytania klienta. Punktem wejścia dla projektu będącego częścią niniejszej pracy jest artykuł \cite{lsp_sample} opisujący utworzenie prostego serwera LSP.

\begin{figure}[H]
    \centering
\begin{tabular}{|c|c|}
\hline
Nazwa metody & Kierunek komunikacji Klient - Serwer\\
\hline
Initialize & $\hookleftarrow$ \\   
\hline
Initialized & $\rightarrow$ \\
\hline
Shutdown & $\hookleftarrow$ \\   
\hline
Exit & $\rightarrow$ \\
\hline
\end{tabular}
\end{figure}

\section{Zapytanie \texttt{Initialize}}
\begin{lstlisting}[language=JavaScript, basicstyle=\fontsize{9}{10}\ttfamily]
interface InitializeParams {
    processId: number | null
    rootPath?: string | null
    rootUri: DocumentUri | null
    initializationOptions?: any
    capabilities: ClientCapabilities
    trace?: 'off' | 'messages' | 'verbose'
}

interface ClientCapabilities {
    workspace?: WorkspaceClientCapabilities
    textDocument?: TextDocumentClientCapabilities
    experimental?: any
}

interface WorkspaceClientCapabilities {
    applyEdit?: boolean
    workspaceEdit?: { documentChanges?: boolean }
    didChangeConfiguration?: { dynamicRegistration?: boolean }
    didChangeWatchedFiles?: { dynamicRegistration?: boolean }
    symbol?: {
        dynamicRegistration?: boolean
        symbolKind?: { valueSet?: SymbolKind[] }
    }
    executeCommand?: { dynamicRegistration?: boolean }
}

interface TextDocumentClientCapabilities {
    synchronization?: {
        dynamicRegistration?: boolean
        willSave?: boolean
        willSaveWaitUntil?: boolean
        didSave?: boolean
    }
    completion?: {
        dynamicRegistration?: boolean
        completionItem?: {
            snippetSupport?: boolean
            commitCharactersSupport?: boolean
            documentationFormat?: MarkupKind[]
        }
        completionItemKind?: { valueSet?: CompletionItemKind[] }
        contextSupport?: boolean		
    }
    hover?: {
        dynamicRegistration?: boolean
        contentFormat?: MarkupKind[]
    }
    signatureHelp?: {
        dynamicRegistration?: boolean
        signatureInformation?: { documentationFormat?: MarkupKind[] }
    }
    references?: { dynamicRegistration?: boolean }
    documentHighlight?: { dynamicRegistration?: boolean }
    documentSymbol?: {
        dynamicRegistration?: boolean
        symbolKind?: { valueSet?: SymbolKind[] }
    }
    formatting?: { dynamicRegistration?: boolean }
    rangeFormatting?: { dynamicRegistration?: boolean }
    onTypeFormatting?: { dynamicRegistration?: boolean }
    definition?: { dynamicRegistration?: boolean }
    codeAction?: { dynamicRegistration?: boolean }
    codeLens?: { dynamicRegistration?: boolean }
    documentLink?: { dynamicRegistration?: boolean }
	rename?: { dynamicRegistration?: boolean }
}
\end{lstlisting}

\begin{lstlisting}[language=JavaScript, basicstyle=\fontsize{9}{10}\ttfamily]
interface InitializeResult {
    capabilities: ServerCapabilities
}

interface ServerCapabilities {
    textDocumentSync?: TextDocumentSyncOptions | number
    hoverProvider?: boolean
    completionProvider?: CompletionOptions
    signatureHelpProvider?: SignatureHelpOptions
    definitionProvider?: boolean
    referencesProvider?: boolean
    documentHighlightProvider?: boolean
    documentSymbolProvider?: boolean
    workspaceSymbolProvider?: boolean
    codeActionProvider?: boolean
    codeLensProvider?: CodeLensOptions
    documentFormattingProvider?: boolean
    documentRangeFormattingProvider?: boolean
    documentOnTypeFormattingProvider?: DocumentOnTypeFormattingOptions
    renameProvider?: boolean
    documentLinkProvider?: DocumentLinkOptions
    executeCommandProvider?: ExecuteCommandOptions
    experimental?: any
}

namespace TextDocumentSyncKind {
     const None = 0
     const Full = 1
     const Incremental = 2
}

interface CompletionOptions {
    resolveProvider?: boolean
    triggerCharacters?: string[]
}

interface SignatureHelpOptions {
    triggerCharacters?: string[]
}

interface CodeLensOptions {
    resolveProvider?: boolean
}

interface DocumentOnTypeFormattingOptions {
    firstTriggerCharacter: string
    moreTriggerCharacter?: string[]
}

interface DocumentLinkOptions {
    resolveProvider?: boolean
}

interface ExecuteCommandOptions {
    commands: string[]
}

interface SaveOptions {
    includeText?: boolean
}

interface TextDocumentSyncOptions {
    openClose?: boolean
    change?: number
    willSave?: boolean
    willSaveWaitUntil?: boolean
    save?: SaveOptions
}
\end{lstlisting}
W odpowiedzi na to zapytanie serwer zwraca informacje na temat jego możliwości. W przypadku tej pracy są to:

\begin{itemize}
    \item Znalezienie definicji danej zmiennej lub funkcji.
    \item Automatyczne sugestie pisanego kodu.
    \item Wyświetlenie informacji na temat danego symbolu.
\end{itemize}

\section{Komunikaty generujące drzewa}
\subsection{Komunikat \texttt{DidChangeTextDocument}}
Komunikat \texttt{DidChangeTextDocument} informuje serwer, że użytkownik dokonał zmian w danym pliku. Uruchomiony zostaje wtedy parser, który czyta treść rzeczonego pliku (możliwością jest pracowanie na samej treści zmiany, jednakże wiązałoby się to z koniecznością napisania własnego parsera wspierającego inkrementalne zmiany w parsowanym tekście). Jeżeli parser napotkał jakiś błąd, jest on zwracany z powrotem do klienta i wyświetlany użytkownikowi pod postacią czerwonego podkreślenia problematycznego fragmentu kodu. Przy udanym parsowaniu otrzymane drzewo jest zapisywane w pamięci, aby można było je odwiedzić przy odpowiadaniu na inne zapytania.

\subsection{Komunikat \texttt{DicChangeConfiguration}}
Komunikat \texttt{DidChangeConfiguration} informuje nas, że użytkownik zmienił ustawienia edytora, co mogło wpłynąć na pliki w niekontrolowany przez nas sposób. W takim przypadku następuje ponowne parsowanie wszystkich otwartych dokumentów analogicznie do komunikatu \texttt{DidChangeTextDocument}.

\section{Zapytania przechodzące po drzewie}
\subsection{Funkcja \texttt{TraverseTreeDown}}
Każde z zapytań które mają w efekcie przejść się po drzewie rozbioru dostarcza nam informacje na temat pozycji w pliku na której się znajduje kursor. W takim razie wydzielona została funkcjonalność tłumaczenia pozycji na węzeł drzewa. Ponieważ każdy z węzłów drzewa rozbioru zawiera informację na temat zakresu tegoż węzła, wystarczy przejść się wgłąb drzewa tak długo jak szukana pozycja znajduje się wewnątrz zakresu przeszukiwanego wierzchołka. Funkcja zwraca odnaleziony wierzchołek.

\subsection{Zapytanie \texttt{Hover}}
Zapytanie \texttt{Hover} pyta się o możliwe informacje do wyświetlenia gdy użytkownik najedzie kursorem myszy na daną pozycję w pliku. Po znalezieniu najlepiej pasującego wierzchołka za pomocą funkcji \texttt{TraverseTreeDown}, zwracany jest komunikat którego dokładna treść jest określana na podstawie typu wierzchołka (np. dla funkcji będzie to jej nazwa i lista argumentów, a dla zmiennej jej typ).

\subsection{Zapytanie \texttt{GotoDefinition}}
Zapytanie \texttt{GotoDefinition} odpowiada akcji polegającej na szukaniu miejsca zdefiniowania danego symbolu w kodzie. Po znalezieniu szukanego symbolu następuje ponowne przejście po drzewie w celu odnalezienia najpóźniejszej definicji tegoż symbolu (w języku Lua symbole mogą być definiowane na nowo w trakcie działania programu, a także przesłaniane za pomocą słowa kluczowego \texttt{local}). Zwracana jest pozycja odnalezionej definicji.

\subsection{Zapytanie \texttt{Completion}}
Zapytanie \texttt{Completion} jest wysyłane przez klienta w celu odpytania serwera na temat możliwego dokończenia aktualnie pisanego tekstu. Również i w tym przypadku dostarczana jest pozycja kursora, jednakże serwer nie szuka aktualnie edytowanego wierzchołka, tylko listę symboli które zostały zdefiniowane i są dostępne w danym kontekście. Lista odnalezionych symboli jest później rozszerzana o funkcje i zmienne zdefiniowane w bibliotece standardowej Lua (informacje na ich temat znajdują się w osobnym pliku JSON, który został utworzony na podstawie dokumentacji języka \cite{lua_lib}).