\chapter{Implementacja serwera LSP}
Dysponując parserem kodu Lua, wystarczy odpowiednio przechodzić generowane przez niego drzewa, w celu odpowiedzi na poszczególne zapytania klienta. Punktem wejścia dla projektu będącego częścią niniejszej pracy jest artykuł \cite{lsp_sample} opisujący utworzenie prostego serwera LSP.

\section{Budowa serwera LSP}

\section{Wypis protokołu LSP}
Protokół LSP, ze względu na szeroką gamę możliwości nowoczesnych edytorów kodu, ma niespełna 40 rodzajów zapytań i komunikatów. Poniżej znajduje się tabela z wypisem metod tegoż interfejsu, a w następnych podrozdziałach nastąpi szczegółowy opis zaimplementowanych w ramach tej pracy rodzajów wiadomości.

\begin{figure}[H]
    \centering
\begin{tabular}{|c|c|}
\hline
Nazwa metody & Kierunek komunikacji Klient - Serwer\\
\hline
Initialize & $\hookleftarrow$ \\   
\hline
Initialized & $\rightarrow$ \\
\hline
Shutdown & $\hookleftarrow$ \\   
\hline
Exit & $\rightarrow$ \\
\hline
ShowMessage & $\leftarrow$ \\
\hline
ShowMessage & $\hookrightarrow$ \\
\hline
LogMessage & $\leftarrow$ \\
\hline
Telemetry & $\leftarrow$ \\
\hline
RegisterCapability & $\hookrightarrow$ \\
\hline
UnregisterCapability & $\hookrightarrow$ \\
\hline
DidChangeConfiguration & $\rightarrow$ \\
\hline
DidChangeWatchedFiles & $\rightarrow$ \\
\hline
Symbol & $\hookleftarrow$ \\
\hline
ExecuteCommand & $\hookleftarrow$ \\
\hline
ApplyEdit & $\hookrightarrow$ \\
\hline
DidOpen & $\rightarrow$ \\
\hline
DidChange & $\rightarrow$ \\
\hline
WillSave & $\rightarrow$ \\
\hline
WillSaveWaitUntil & $\hookleftarrow$ \\
\hline
DidSave & $\rightarrow$ \\
\hline
DidClose & $\rightarrow$ \\
\hline
PublishDiagnostics & $\leftarrow$ \\
\hline
Completion & $\hookleftarrow$ \\
\hline
Completion Resolve & $\hookleftarrow$ \\
\hline
Hover & $\hookleftarrow$ \\
\hline
SignatureHelp & $\hookleftarrow$ \\
\hline
Definition & $\hookleftarrow$ \\
\hline
References & $\hookleftarrow$ \\
\hline
DocumentHighlight & $\hookleftarrow$ \\
\hline
DocumentSymbol & $\hookleftarrow$ \\
\hline
CodeAction & $\hookleftarrow$ \\
\hline
CodeLens & $\hookleftarrow$ \\
\hline
CodeLens Resolve & $\hookleftarrow$ \\
\hline
DocumentLink & $\hookleftarrow$ \\
\hline
DocumentLink Resolve & $\hookleftarrow$ \\
\hline
Formatting & $\hookleftarrow$ \\
\hline
RangeFormatting & $\hookleftarrow$ \\
\hline
OnTypeFormatting & $\hookleftarrow$ \\
\hline
Rename & $\hookleftarrow$ \\
\hline
\end{tabular}
\end{figure}

\section{Zapytanie \texttt{Initialize}}
\begin{lstlisting}[language=JavaScript, basicstyle=\fontsize{9}{10}\ttfamily, title=Struktura argumentu zapytania]
interface InitializeParams {
    processId: number | null
    rootPath?: string | null
    rootUri: DocumentUri | null
    initializationOptions?: any
    capabilities: ClientCapabilities
    trace?: 'off' | 'messages' | 'verbose'
}

interface ClientCapabilities {
    workspace?: WorkspaceClientCapabilities
    textDocument?: TextDocumentClientCapabilities
    experimental?: any
}

interface WorkspaceClientCapabilities {
    applyEdit?: boolean
    workspaceEdit?: { documentChanges?: boolean }
    didChangeConfiguration?: { dynamicRegistration?: boolean }
    didChangeWatchedFiles?: { dynamicRegistration?: boolean }
    symbol?: {
        dynamicRegistration?: boolean
        symbolKind?: { valueSet?: SymbolKind[] }
    }
    executeCommand?: { dynamicRegistration?: boolean }
}

interface TextDocumentClientCapabilities {
    synchronization?: {
        dynamicRegistration?: boolean
        willSave?: boolean
        willSaveWaitUntil?: boolean
        didSave?: boolean
    }
    completion?: {
        dynamicRegistration?: boolean
        completionItem?: {
            snippetSupport?: boolean
            commitCharactersSupport?: boolean
            documentationFormat?: MarkupKind[]
        }
        completionItemKind?: { valueSet?: CompletionItemKind[] }
        contextSupport?: boolean		
    }
    hover?: {
        dynamicRegistration?: boolean
        contentFormat?: MarkupKind[]
    }
    signatureHelp?: {
        dynamicRegistration?: boolean
        signatureInformation?: { documentationFormat?: MarkupKind[] }
    }
    references?: { dynamicRegistration?: boolean }
    documentHighlight?: { dynamicRegistration?: boolean }
    documentSymbol?: {
        dynamicRegistration?: boolean
        symbolKind?: { valueSet?: SymbolKind[] }
    }
    formatting?: { dynamicRegistration?: boolean }
    rangeFormatting?: { dynamicRegistration?: boolean }
    onTypeFormatting?: { dynamicRegistration?: boolean }
    definition?: { dynamicRegistration?: boolean }
    codeAction?: { dynamicRegistration?: boolean }
    codeLens?: { dynamicRegistration?: boolean }
    documentLink?: { dynamicRegistration?: boolean }
	rename?: { dynamicRegistration?: boolean }
}
\end{lstlisting}

\begin{lstlisting}[language=JavaScript, basicstyle=\fontsize{9}{10}\ttfamily, title=Struktura odpowiedzi]
interface InitializeResult {
    capabilities: ServerCapabilities
}

interface ServerCapabilities {
    textDocumentSync?: TextDocumentSyncOptions | number
    hoverProvider?: boolean
    completionProvider?: CompletionOptions
    signatureHelpProvider?: SignatureHelpOptions
    definitionProvider?: boolean
    referencesProvider?: boolean
    documentHighlightProvider?: boolean
    documentSymbolProvider?: boolean
    workspaceSymbolProvider?: boolean
    codeActionProvider?: boolean
    codeLensProvider?: CodeLensOptions
    documentFormattingProvider?: boolean
    documentRangeFormattingProvider?: boolean
    documentOnTypeFormattingProvider?: DocumentOnTypeFormattingOptions
    renameProvider?: boolean
    documentLinkProvider?: DocumentLinkOptions
    executeCommandProvider?: ExecuteCommandOptions
    experimental?: any
}

namespace TextDocumentSyncKind {
     const None = 0
     const Full = 1
     const Incremental = 2
}

interface CompletionOptions {
    resolveProvider?: boolean
    triggerCharacters?: string[]
}

interface SignatureHelpOptions {
    triggerCharacters?: string[]
}

interface CodeLensOptions {
    resolveProvider?: boolean
}

interface DocumentOnTypeFormattingOptions {
    firstTriggerCharacter: string
    moreTriggerCharacter?: string[]
}

interface DocumentLinkOptions {
    resolveProvider?: boolean
}

interface ExecuteCommandOptions {
    commands: string[]
}

interface SaveOptions {
    includeText?: boolean
}

interface TextDocumentSyncOptions {
    openClose?: boolean
    change?: number
    willSave?: boolean
    willSaveWaitUntil?: boolean
    save?: SaveOptions
}
\end{lstlisting}
Zapytanie \texttt{Initialize} posiada masywny interfejs zarówno argumentu zapytania klienta, jak i odpowiedzi serwera. Jest tak ze względu na możliwość implementacji dowolnego fragmentu interfejsu LSP. Przy odpowiadaniu na to zapytanie serwer zwraca przygotowany wcześniej obiekt JSON określający jakie funkcjonalności implementuje. W przypadku tej pracy są to:

\begin{itemize}
    \item Znalezienie definicji danej zmiennej lub funkcji.
    \item Automatyczne sugestie pisanego kodu.
    \item Wyświetlenie informacji na temat danego symbolu.
\end{itemize}

\section{Komunikaty generujące drzewa}
\subsection{Komunikat \texttt{DidChangeTextDocument}}
\begin{lstlisting}[title=Struktura argumentu komunikatu]
interface DidChangeTextDocumentParams {
    textDocument: VersionedTextDocumentIdentifier
    contentChanges: TextDocumentContentChangeEvent[]
}

interface VersionedTextDocumentIdentifier {
    uri: string
    version: number
}

interface TextDocumentContentChangeEvent {
    range?: Range
    rangeLength?: number
    text: string
}

interface Range {
    start: Position
    end: Position
}

interface Position {
    line: number
    character: number
}
\end{lstlisting}

Komunikat \texttt{DidChangeTextDocument} zostaje przesłany do serwera gdy użytkownik zmodyfikował treść pliku (niekoniecznie plik został po tych zmianach zapisany). Należy tutaj nadmienić, że protokół LSP wspiera dwie metody synchronizacji treści pliku między klientem a serwerem, pełną w której każdy komunikat o zmianie pliku zawiera całkowitą treść tego pliku, lub inkrementalny, w którym przesyłane są jedynie pozycje i treść zmienionych fragmentów. Tryb synchronizacji jest określany w odpowiedzi na zapytanie \texttt{Initialize}. Na potrzeby tej pracy zaimplementowano tryb pełny. Po otrzymaniu komunikatu serwer uruchamia parser języka Lua na treści pliku przesłanej w komunikacie. Jeżeli parser napotkał jakiś błąd, jest on zwracany z powrotem do klienta i wyświetlany użytkownikowi pod postacią czerwonego podkreślenia problematycznego fragmentu kodu. Przy udanym parsowaniu otrzymane drzewo jest zapisywane w pamięci, aby można było je odwiedzić przy odpowiadaniu na inne zapytania.

\subsection{Komunikat \texttt{DicChangeConfiguration}}
Komunikat \texttt{DidChangeConfiguration} informuje nas, że użytkownik zmienił ustawienia edytora, co mogło wpłynąć na pliki w niekontrolowany przez nas sposób. W takim przypadku następuje ponowne parsowanie wszystkich otwartych dokumentów analogicznie do komunikatu \texttt{DidChangeTextDocument}.

\section{Zapytania przechodzące po drzewie}
\subsection{Funkcja \texttt{TraverseTreeDown}}
Każde z zapytań które mają w efekcie przejść się po drzewie rozbioru dostarcza nam informacje na temat pozycji w pliku na której się znajduje kursor. W takim razie wydzielona została funkcjonalność tłumaczenia pozycji na węzeł drzewa. Ponieważ każdy z węzłów drzewa rozbioru zawiera informację na temat zakresu tegoż węzła, wystarczy przejść się wgłąb drzewa tak długo jak szukana pozycja znajduje się wewnątrz zakresu przeszukiwanego wierzchołka. Funkcja zwraca odnaleziony wierzchołek.

\subsection{Zapytanie \texttt{Hover}}
Zapytanie \texttt{Hover} pyta się o możliwe informacje do wyświetlenia gdy użytkownik najedzie kursorem myszy na daną pozycję w pliku. Po znalezieniu najlepiej pasującego wierzchołka za pomocą funkcji \texttt{TraverseTreeDown}, zwracany jest komunikat którego dokładna treść jest określana na podstawie typu wierzchołka (np. dla funkcji będzie to jej nazwa i lista argumentów, a dla zmiennej jej typ).

\subsection{Zapytanie \texttt{GotoDefinition}}
Zapytanie \texttt{GotoDefinition} odpowiada akcji polegającej na szukaniu miejsca zdefiniowania danego symbolu w kodzie. Po znalezieniu szukanego symbolu następuje ponowne przejście po drzewie w celu odnalezienia najpóźniejszej definicji tegoż symbolu (w języku Lua symbole mogą być definiowane na nowo w trakcie działania programu, a także przesłaniane za pomocą słowa kluczowego \texttt{local}). Zwracana jest pozycja odnalezionej definicji.

\subsection{Zapytanie \texttt{Completion}}
Zapytanie \texttt{Completion} jest wysyłane przez klienta w celu odpytania serwera na temat możliwego dokończenia aktualnie pisanego tekstu. Również i w tym przypadku dostarczana jest pozycja kursora, jednakże serwer nie szuka aktualnie edytowanego wierzchołka, tylko listę symboli które zostały zdefiniowane i są dostępne w danym kontekście. Lista odnalezionych symboli jest później rozszerzana o funkcje i zmienne zdefiniowane w bibliotece standardowej Lua (informacje na ich temat znajdują się w osobnym pliku JSON, który został utworzony na podstawie dokumentacji języka \cite{lua_lib}).